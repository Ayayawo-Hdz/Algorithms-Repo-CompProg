%"The PDF file may contain up to 25 pages of reference material, single-sided, letter or A4 size, with text and illustrations readable by a person with correctable eyesight without magnification from a distance of 1/2 meter."
\input{preamble.tex}
\begin{document}
\def\title{UACJ - Codesnatchers}
.\\[0.2cm]
\centering{\LARGE\textbf{Codesnatchers}} \\[0.5cm]
\centering{\includegraphics[width=5.5cm]{lain.jpg}}
\tableofcontents\newpage

\section{Template}
\cppfile{template.cpp}
\section{Data structures}
\subsection{STL Algorithms}
\begin{justify}
STL stands for Standard Template Library. It is a library that provides several generic 
classes and functions, allowing programmers to manipulate data structures in an easy and efficient way.
The STL provides a range of algorithms which can be used to manipulate data stored in containers. The following 
list shows some of the algorithms provided by the STL and its functions:
\end{justify}
\textbf{Non-Manipulating Algorithms}
\begin{itemize}
\item \textbf{sort(first\_iterator, last\_iterator)} - Sorts the elements in the range [first, last) in ascending order.
\item \textbf{sort(frst\_iterator, last\_iterator, greater\textless int\textgreater())} - Sorts elements inside the vector, in descending order.
\item \textbf{reverse(first\_iterator, last\_iterator)} - Reverses elements inside a vector.
\item \textbf{*max\_element(first\_iterator, last\_iterator)} - Finds the maximum element of a vector.
\item \textbf{*min\_element(first\_iterator, last\_iterator)} - Finds the minimum element of a vector.
\item \textbf{accumulate(first\_iterator, last\_iterator, initial value of sum)} - Summates all the vector elements.
\item \textbf{count(first\_iterator, last\_iterator, x)} - Counts all occurrences 'x' inside a vector. It has a linear complexity over the quantity of occurrences inside the container; if you fill a set with just one element, the count() function over that element will have an overall complexity of $O(|set|)$ where $|set|$ is the cardinality of the set. 
\item \textbf{find(first\_iterator, last\_iterator, x)} - Returns an iterator to the first occurrence of 'x' in vector and points to last address if the element is not present.
\item \textbf{binary\_search(first\_iterator, last\_iterator, x)} - Tests if 'x' exists in sorted vector or not.
\item \textbf{lower\_bound(first\_iterator, last\_iterator, x)} - Returns an element pointing to the first element in range [first, last), which has a value less than 'x'. Notice that it has a linear complexity over sets and multisets, to avoid this it is necessary to use the member method of those containers. 
\item \textbf{upper\_bound(first\_iterator, last\_iterator, x)} - Returns an element pointing to the first element in range [first, last), which has a value greater than 'x'.
\end{itemize}
\textbf{Manipulating Algorithms}
\begin{itemize}
\item \textbf{arr.erase(position to delete)} - Erases selected element in vector and shifts and resizes it accordingly.
\item \textbf{arr.erase(unique(arr.begin(), arr.end()), arr.end())} - Erases the duplicate occurrences in sorted vector in a single line.
\item \textbf{next\_permutation(first\_iterator, last\_iterator)} - Modifies the vector to its next permutation.
\item \textbf{prev\_permutation(first\_iterator, last\_iterator)} - Modifies the vector to its previous permutation.
\item \textbf{distance(first\_iterator, desired\_iterator)} - Returns the distance of the desired position from the first iterator to a desired one.
\end{itemize}
\subsection{Binary Search}
\cppfile{Data-Structures/binary_search.cpp}
\subsection{Simplified DSU (Stolen from GGDem)}
\subsection{Disjoint Set Union}
\subsection{Segment Tree}
\cppfile{Data-Structures/segment_tree.cpp}
\subsection{Segment Tree Lazy}
\subsection{Trie}


\section{Graphs}
\subsection{Graph Transversal}
\subsubsection{BFS}
\cppfile{Graphs/breadth_first_search.cpp}
\subsubsection{DFS}
\cppfile{Graphs/depth_first_search.cpp}
\subsubsection{BFS / DFS using queue and stack}
\cppfile{Graphs/bfs_dfs.cpp}
\subsection{Topological Sort}
\subsection{APSP: Floyd Warshall}
\subsection{SSSP}
\subsubsection{Lazy Dijkstra}
\cppfile{Graphs/lazy_dijkstra.cpp}
\subsubsection{Bellman-Ford}
\subsection{Strongly Connected Components: Kosaraju}
\subsection{Articulation Points and Bridges: ModTarjan}

\section{Math}
\subsection{Identities}
{

\textbf{Coeficientes binomiales.}

$(a+b)^{n} = \Sigma_{k = 0}^{n} \binom{n}{k}a^{n-k}b^{k}$

$\binom{n}{k} = \binom{n}{n-k}$

$\binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}$

$k\binom{n}{k} = n\binom{n-1}{k-1}$

$\Sigma_{k = 0}{n}\binom{n}{k} = 2^{n}$

$\Sigma_{k = 0}^{n} (-1)^{k}\binom{n}{k} = 0$

$\binom{n+m}{t} = \Sigma_{k = 0}^{t}\binom{n}{k}\binom{m}{t-k}$

$\Sigma_{j = k}^{n} \binom{j}{k} = \binom{n+1}{k+1}$

\textbf{Números Catalanes.}

$C_n = \frac{2(2n-1)}{n+1} C_{n-1}$

$C_n = \frac{1}{n+1} \binom{2n}{n}$

$C_n \sim \frac{4^n}{n^{3/2}\sqrt{\pi}}$

$\Sigma(n) = O(\log(\log(n)))$ (number of divisors of $n$)

$F_{2n+1} = F_{n}^2 + F_{n+1}^2$

$F_{2n} = F_{n+1}^2 - F_{n-1}^2$

$\sum_{i=1}^n F_i = F_{n+2}-1$

$F_{n+i}F_{n+j} - F_nF_{n+i+j} = (-1)^n F_iF_j$

\textbf{(Möbius Function)}

0 if n is square-free

1 if n got even amount of distinct prime factors

0 if n got odd amount of distinct prime factors

\textbf{(Möbius Inv. Formula)}

Let $g(n) = \sum_{d\mid n} f(d)$, then $f(n)=\sum{d\mid n} g(d) \mu\left(\frac{n}{d})\right)$.
}
\\
\textbf{Permutaciones objetos repetidos}

$P(n,k) = \frac{P(n,k)}{n_{1}!n_{2}!...}$ 
\\
\textbf{Separadores, Ecuaciones lineares $a$ variables $= b$}
  
$\left(\binom{a}{b}\right) = \binom{a+b-1}{b} = \binom{a+b-1}{a-1}$

\textbf{Teorema chino}

sean $\{n_{1}, n_{2},..., n_{k} \}$ primos relativos\\

$P = n_{1}\cdot n_{2}\cdot ...\cdot n_{k}$

$P_{i} = \frac{P}{n_{i}}$

$x\cong a_{1}(n_{1})$

$x\cong a_{2}(n_{2})$
$...$
$x\cong a_{k}(n_{k})$

$P_{1}S_{1} \cong 1(n_{1})$ Donde $S$ soluciones.

$x = P_{1}S_{1}a_{1} + P_{2}S_{2}a_{2} ... P_{k}S_{k}a_{k}$


\subsection{Binary Exponentiation and Modular Arithmetic}
\subsubsection{Binary Exponentiation}
\cppfile{Math/binary_exponentiation.cpp}
\subsubsection{Modular Arithmetic}
\begin{justify}
Modular airhmetic is a system of arithmetic for integers, which considers the remainder.
In modulus, numbers "wrap around" upon reaching a fixed value.\\ \\
\textbf{Congruence}\\
A number $x$ mod $N$ is the equivalent of the remainder of the division of $x$ by $N$.
Two numbers $a$ and $b$ are congruent modulo $N$ if they have the same remainder
upon division by $N$. We say that $N$ if $a$ mod $N = b$ mod $N$.
\begin{itemize}
\item \textbf{For example:} $54 \equiv 24$ (mod $7$)\\Both numbers are congruent modulo 7, 
since $54$ mod $7 = 3$ and $24$ mod $7 = 3$.
\end{itemize}
Another way of defining this is by saying that $a$ and $b$ are congruent modulo $N$ if their 
difference $(a-b)$ is an integer multiple of $n$, that is, if $\frac{a - b}{n}$ has a reminder of 0.
\begin{itemize}
\item \textbf{For example:} $36 \equiv 10$ (mod $13$)\\$36$ and $10$ are congruent modulo 13, since
their difference $36-10 = 26$ is a multiple of 13 ($n = 13$).
\end{itemize}
\textbf{Addition}\\
\textbf{Properties of addition in Modular Arithmetic:}
\begin{enumerate}
\item If $a + b = c$ then $a$ (mod $N$) $+ b$ (mod $N$) $\equiv c$ (mod $N$).
\item If $a \equiv b$ (mod $N$), then $a + k \equiv b + k$ (mod $N$) for any integer $k$.
\item If $a \equiv b$ (mod $N$) and $c \equiv d$ (mod $N$), then $a + c \equiv b + d$ (mod $N$).
\item If $a \equiv b$ (mod $N$), then $-a \equiv -b$ (mod $N$).
\end{enumerate}
\begin{itemize}
\item \textbf{For example:} Find the sum of $31$ and $148$ in modulo $24$.\\
$31$ in modulo $24$ is $7$ and $148$ in modulo $24$ is $4$. Thus, $31 + 148 \equiv 7 + 4 \equiv 11$ (mod $24$).
\item \textbf{Another example:} Find the remainder when $123 + 234 + 32 + 56 + 22 + 12 + 78$ is divided by $3$.\\
We know that $123$ mod $3 = 0$, $234$ mod $3 = 0$, $32$ mod $3 = 2$, $56$ mod $3 = 2$, $22$ mod $3 = 1$, $12$ mod $3 = 0$, and $78$ mod $3 = 0$. 
Thus, the sum of all these numbers is $0 + 0 + 2 + 2 + 1 + 0 + 0 = 5$, and $5$ mod $3 = 2$.
\end{itemize}
\textbf{Multiplication}\\
\textbf{Properties of multiplication in Modular Arithmetic:}
\begin{enumerate}
\item If $a \cdot b = c$, then $a$ (mod $N$) $\cdot b$ (mod $N$) $\equiv c$ (mod $N$).
\item If $a \equiv b$ (mod $N$), then $a \cdot k \equiv b \cdot k$ (mod $N$) for any integer $k$.
\item If $a \equiv b$ and $c \equiv d$ (mod $N$), then $a \cdot c \equiv b \cdot d$ (mod $N$).
\end{enumerate}
\begin{itemize}
\item \textbf{For example:} What is $(8 \cdot 16)$ (mod $7$).\\
Since $8 \equiv 1$ (mod $7$) and $16 \equiv 2$ (mod $7$), then $(8 \cdot 16) \equiv (1 \cdot 2) \equiv 2$ (mod $7$).
\item \textbf{Another example:} What is the remainder when $123 \cdot 234 \cdot 32 \cdot 56 \cdot 22 \cdot 12 \cdot 78$ is divided by $3$.\\
We know that $123 \equiv 1$, $134 \equiv 2$, $23 \equiv 2$, $49 \equiv 1$, $235 \equiv 1$ and $13 \equiv 1$, therefore:\\
$123 \cdot 234 \cdot 32 \cdot 56 \cdot 22 \cdot 12 \cdot 78 \equiv 1 \cdot 2 \cdot 2 \cdot 1 \cdot 1 \cdot 1 \equiv 4 \equiv 1$ (mod $3$).
Leaving a remainder of $1$.
\end{itemize}
\end{justify}
\cppfile{Math/modular_arithmetic.cpp}
\subsection{Modular Inverse}
\begin{justify}
The modular inverse of an integer $a$ modulo $m$ is an integer $x$ such that $ax \equiv 1$ (mod $m$).\\
\begin{itemize}
\item If $a$ and $N$ are integers such that $gcd(a, N) = 1$, then there exists an integer $x$ such that $ax \equiv 1$ (mod $N$).\\
$x$ is called the modular inverse of $a$ modulo $N$.
\end{itemize}
However, $\frac{a}{b}$ (mod $N$) is not the same as $(\frac{(a \mod N)}{(b \mod N)})$ (mod $N$).\\
\begin{itemize}
\item Lets take $a = 10$, $b = 2$, and $N = 3$.\\
$\frac{10}{2}$ (mod $3$) = $5$ (mod $3$) = $2$ ; $(\frac{10 \mod 3}{2 \mod 3})$ (mod $3$) = $(\frac{1}{2})$ (mod $3$) = $0.5$.\\
This discrepancy is due to the fact that division is not always compatible with modular arithmetic.
\end{itemize}
On the other hand, using the extended Euclidean algorithm, we can find the modular inverse of $a$ modulo $N$:
\end{justify}
\cppfile{Math/extended_euclidean.cpp}
\subsection{Modular Binomial Coeficient and Permutations}
\subsection{Non-Mod Binomial Coeficient and Permutations}
\subsection{Modular Catalan Numbers}
\subsection{Fractional Ceiling}
\cppfile{Math/ceil_fraccionario.cpp}
\subsection{Fibonacci Numbers}
\cppfile{Math/fibonacci_numbers.cpp}
\subsection{Sieve Of Eratosthenes}
\cppfile{Math/sieve_eratosthenes.cpp}
\subsection{Sieve-based Factorization}
\cppfile{Math/sieve_number_factorization.cpp}
\subsection{Prime number factorization}
\cppfile{Math/prime_factorization.cpp}
\subsection{Cycle Finding}
\subsection{Berlekamp Massey}
\subsection{Modular Berlekamp Massey}
\subsection{Matrix exponentiation}
\subsection{Ecuaciones Diofantinas}
\subsection{Pollard-Rho, Stolen from GGDem}
\subsection{FFT, Stolen from GGDem}
\subsection{Euler Totient Function}
\section{Geometry}


\section{Strings}
\subsection{Explode by token}
\cppfile{Strings/explode_by_token.cpp}
\subsection{Multiple Hashings DS}
\subsection{Permute chars of string}
\subsection{Longest common subsequence}
\subsection{KMP}
\subsection{Suffix Array}
\subsection{STL Suffix Array}
\section{Classics}
\subsection{Job scheduling}
\subsubsection{One machine, linear penalty}
\subsubsection{One machine, deadlines}
\subsubsection{One machine, profit}
\subsubsection{Two machines, min time}

\section{Flow}
\subsection{Dinic}
\cppfile{Flow/dinic.cpp}

\section{Miscellaneous}
\subsection{Policy Based Data Structures}
\cppfile{Misc/order_statistic_tree.cpp}
\subsection{Bit Manipulation}
\cppfile{Misc/bit_manipulation.cpp}
\subsubsection{Bitmasking}
\begin{justify}
Bitmasking is a technique used in computer programming to solve problems using individual or groups of bits within a binary number.\\
It is a powerful tool to solve problems that involve subsets, permutations, and combinations; using bitwise operations such as AND, OR,
XOR and NOT.\\
\textbf{Some bitmasking utilities are:}
\begin{itemize}
\item \textbf{Memory efficiency:} Bitmasks can be used for compact and memory efficient storage big collections of data.
\item \textbf{Subset, permutation and combination generation:} Can be used to generate all possible subsets, permutations and combinations of a set.
\item \textbf{Set operations:} Can be used to perform set operations such as union, intersection, and difference.
\item \textbf{Data masking and filtering:} By selectively turning on or off bits, we can filter out or mask certain data.
\item \textbf{Optimization:} Algorithm optimization can be achieved using bitmasking, substituing bit-level operations for arithmetic operations.
\end{itemize}
\end{justify}

\section{Testing}
\subsection{Gen and AutoRun testcases}
\subsubsection{Gen.cpp}
\subsubsection{Stress testing}
%\lstinputlisting[language={bash}]{Testing/test.sh}
\subsubsection{Autorun}
%\lstinputlisting[language={bash}]{Testing/runAllTests.sh}
\subsection{Highly Composite Numbers}
Particularly useful when testing number theoretical solutions.
\lstinputlisting[language={}]{Testing/highlycomposite.txt}


\end{document}

